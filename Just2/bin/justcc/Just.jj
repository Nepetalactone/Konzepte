options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(JUSTParser)package justcc;import java.io.FileInputStream;import symbol.Kind;import symbol.MethodSymbol;import symbol.NameList;import symbol.Scope;import symbol.Symbol;import symbol.SymbolTable;import symbol.Type;import classfile.ClassFile;import classfile.constant.Constant;import classfile.constant.MethodRefConstant;import code.CodeGenerator;import code.Descriptor;import code.fixup.VarAddressFixup;import code.OpCode;public class JUSTParser{  private static ClassFile m_classFile = new ClassFile();  private static NameList m_nameList = new NameList();  private static SymbolTable m_symboltable = new SymbolTable(m_nameList); //Semantikanschluss Seite 41  private static CodeGenerator m_codeGen = new CodeGenerator();  public static void main(String args [])  {    try    {      JUSTParser parser = new JUSTParser(new FileInputStream("JustCode/Test.jus"));      parser.file();      System.out.println("OK.");      m_classFile.write("JustCode/output.jl");    }    catch (ParseException e)    {      System.out.println("NOK.");      System.out.println(e.getMessage());      JUSTParser.ReInit(System.in);    }    catch (Error e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());      e.printStackTrace();    }    catch (Exception e)    {      System.out.println("Other oops.");      System.out.println(e.getMessage());      e.printStackTrace();    }  }}PARSER_END(JUSTParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < ASSIGN : "=" >| < EQUALS : "==" >| < NQ : "!=" > /*Not Equals*/| < GT : ">" > /*Greater than*/| < GET : ">=" > /*Greater than or equal*/| < LT : "<" > /*Lesser than*/| < LET : "<=" > /*Lesser than or equal*/| < NOT : "!" >| < OR : "||" >| < AND : "&&" >}TOKEN : /*punctuation character*/{  < LEFTBRACKET : "(" >| < RIGHTBRACKET : ")" >| < LEFTCURLYBRACKET : "{" >| < RIGHTTCURLYBRACKET : "}" >| < LEFTSQUAREBRACKET : "[" >| < RIGHTSQUAREBRACKET : "]" >| < COLON : "," >| < SEMICOLON : ";" >| < POINT : "." >}TOKEN [ IGNORE_CASE ] : /*keywords*/{  < PROGRAM : "program" >| < VOID : "void" >| < INT : "int" >| < BOOL : "boolean" >| < BYREF : "byref" >| < RETURN : "return" >| < IF : "if" >| < ELSE : "else" >| < WHILE : "while" >| < VAR : "var" >| < CALL : "call" >| < COROUTINE : "coroutine" >| < NEW : "new" >}TOKEN [ IGNORE_CASE ] :{  < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < CONSTANT : (< DIGIT >)+ >| < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >}TOKEN :{  < TRUE : "true" >| < FALSE : "false" >}/*Ab hier einfach die Regeln aus den Folien Abschreiben:file ="program" ident "{" Definition "}".Definition={ VarDef| FuncDef}.VarDef=Type ident[ Init] ";".Init="=" number.Type="void" | "int" | "boolean".FuncDef=FuncHeadBlock.FuncHead=Type ident "(" [ FormParList] ")".FormParList=["byref"] Type ident{"," ["byref"] Type ident}.Block="{" { VarDef| Stat} "}".Stat=AssignStat| CallStat| IfStat| WhileStat| ReturnStat| Block | ";".AssignStat=ident "=" Expr";".CallStat=Call ";".Call=ident "(" [ ActParList] ")".ActParList=Expr{ "," Expr}.IfStat="if" "(" Expr ")" Stat [ "else" Stat ].WhileStat="while" "(" Expr")" Stat.ReturnStat="return" [ Expr] ";" .Expr=OrExpr.OrExpr=AndExpr{ "||" AndExpr}.AndExpr=RelExpr{ "&&" RelExpr}.RelExpr=SimpleExpr[ ("==" | "!=" | "<" | "<=" | ">" | ">=") SimpleExpr].SimpleExpr=["+" | "-"] Term { ("+" | "-") Term }.Term=NotFact{ ("*" | "/") NotFact}.NotFact=["!"] Fact.Fact=number| ident["(" [ ActParList] ")" ]| "(" Expr")".*/void file() :{}{  program() /*Startpunkt für die Kompilierung*/}void program() :{  Symbol s;  Constant classConstant;}{  < PROGRAM > token = < IDENT >  {    s = m_nameList.insert(token.image, Kind.programKind);    m_symboltable.insert(s);    m_symboltable.enterScope("program: " + token.image);    classConstant = m_classFile.addClassConstant(s);  }  < LEFTCURLYBRACKET >  (   // Definition()    fieldVarDef()  | FuncDef()  )*  < RIGHTTCURLYBRACKET >  {    m_symboltable.leaveScope();  }}void fieldVarDef() :{  Constant constant;}{  < VAR > constant = VarDef(Kind.fieldKind)  // TODO add assignment (only Constants)  < SEMICOLON >}void localVarDef() :{  Constant constant;}{  < VAR > constant = VarDef(Kind.localKind)  // TODO add assignment  < SEMICOLON >}Constant VarDef(Kind kind) :{  Type type;  Symbol s;  Constant varConstant;}{  type = Type()  token = < IDENT >  {    s = m_nameList.insert(token.image, kind);    s.setType(type);    m_symboltable.insert(s);    return m_classFile.addVarConstant(s);  }}void FuncDef() :{  Type type;  MethodSymbol s;  MethodRefConstant methodConstant;  Scope scope;}{  type = Type()  token = < IDENT >  {    s = (MethodSymbol) m_nameList.insert(token.image, Kind.methodKind);    s.setType(type);    m_symboltable.insert(s);    scope = m_symboltable.enterScope(token.image);  }  < LEFTBRACKET > FormParList(s) < RIGHTBRACKET >  {    methodConstant = (MethodRefConstant) m_classFile.addMethodConstant(s, scope);    m_codeGen.setCurrentCode(methodConstant.getCode());  }  Block()  {    m_symboltable.leaveScope();  }}Type Type() :{}{  < VOID >  {    return Type.Void;  }| < INT >  {    return Type.Int;  }| < BOOL >  {    return Type.Bool;  }}void Block() :{}{  < LEFTCURLYBRACKET >  (   Stat()  )*  < RIGHTTCURLYBRACKET >}void Stat() :{}{  localVarDef()| AssignStat()| ReturnStat()}void AssignStat() :{  //Seite 41  //Attribute  Descriptor desc;}{  desc = var(false)  < ASSIGN > Expr()  {    m_codeGen.save(desc);  }< SEMICOLON >}void CallStat() :{}{  Call() < SEMICOLON >}void Call() :{}{  < IDENT > < LEFTBRACKET > [ ActParList() ] < RIGHTBRACKET >}void ActParList() :{}{  Expr()  (    < COLON > Expr()  )*}void IfStat() :{  //m_codeGenerierung: Sprünge und Marken 54 // Label endifLabel = null; // Descriptor desc = null;}{  < IF > < LEFTBRACKET > //desc = Expr() //let expr return a description  { //   m_codeGen.falseJump(desc); //   m_codeGen.markByLabel(desc.m_fLabel);  }  < RIGHTBRACKET > Stat() < ELSE >  {   // endifLabel = m_m_codeGen.createLabel();   // m_codeGen.jump(endifLabel);   // m_codeGen.markByLabel(desc.m_fLabel);  }  Stat()  {  // m_codeGen.markByLabel(endifLabel);  }| /*no else*/  {   //m_codeGen.markByLabel(desc.m_fLabel);  }  // [ //LOOKAHEAD(2) /*Vorrausschauen (Vorschlag war 2)*/  //< ELSE >   //Stat() ]}void WhileStat() :{}{  < WHILE > < LEFTBRACKET > Expr() < RIGHTBRACKET > Stat()}void ReturnStat() :{}{  < RETURN > Expr()  {    m_codeGen.emit(OpCode.IRETURN);  }  < SEMICOLON >}void Expr() :{}{  OrExpr()}void OrExpr() :{}{  AndExpr()  (    < OR > AndExpr()    {      m_codeGen.emit(OpCode.IOR);    }  )*}void AndExpr() :{}{  RelExpr()  (    < AND > RelExpr()    {      m_codeGen.emit(OpCode.IAND);    }  )*}void RelExpr() :{}{  SimpleExpr() ( Compare() SimpleExpr())*  //[(< EQUALS >|<  NQ >| < GT >|< GET >|< LT >|< LET > )SimpleExpr()]  }void SimpleExpr() :{  OpCode code;}{  Term()  (    (      < PLUS >      {        code = OpCode.IADD;      }    | < MINUS >      {        code = OpCode.ISUB;      }    )    Term()    {      m_codeGen.emit(code);    }  )*}void Term() :{  OpCode code;}{  NotFact()  (    (      < MULTIPLY >      {        code = OpCode.IMUL;      }    | < DIVIDE >      {        code = OpCode.IDIV;      }    )    NotFact()    {      m_codeGen.emit(code);    }  )*}void NotFact() :{  boolean not = false;}{  (        < NOT >    {      not = true;    })?  Fact()  {    if (not)    {      m_codeGen.emit(OpCode.INEG);    }  }}void Fact() :{  Constant constant;}{ token =  < CONSTANT > {    constant = m_classFile.addValueConstant(token.image, "integer");    m_codeGen.emit2(OpCode.LDC_W, constant.getIndex());  }| var(true)| simpleCallStat()| (< LEFTBRACKET > Expr() < RIGHTBRACKET >)}Descriptor var(boolean generate):{  Symbol s;  Descriptor desc;}{  token = < IDENT >  {    s = m_symboltable.lookup(token.image);    if(s==null)    {      s = m_nameList.insert(token.image, Kind.noneKind);    }    desc = m_codeGen.getDescriptor(s);        if(generate)    {      m_codeGen.load(desc);    }    return desc;  }}void simpleCallStat():{}{  < CALL >  call()}void call() :{  Descriptor desc;}{  desc = var(false)  < LEFTBRACKET >  ActParList()  < RIGHTBRACKET >  {    m_codeGen.emit2(OpCode.INVOKESTATIC, new VarAddressFixup(desc, m_symboltable.getCurScope()));  }}void Compare() :{}{  < EQUALS >| < NQ >| < LT >| < LET >| < GT >| < GET >}void Init() :{}{  < ASSIGN > < CONSTANT >}void FormParList(MethodSymbol s) :{}{  (      formPar(s)  (    < COLON > formPar(s)  )*)?}void formPar(MethodSymbol method) : /*musste aufgeteilt werden, sonst gabs fehler*/{  Type type;  Symbol s;}{  (     < BYREF >  )?   type = Type()    token = < IDENT >  {    s = m_nameList.insert(token.image, Kind.paramKind);    s.setType(type);    m_symboltable.insert(s);    s.setConstant(m_classFile.addVarConstant(s));    method.addParam(s);  }}void sum() :{}{  Term()  (    (      < PLUS >    | < MINUS >    )    Term()  )*}